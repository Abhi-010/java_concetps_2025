collect elements from streams into list

If you‚Äôre talking about Java Streams, you collect elements into a List using a terminal operation.

Basic example
List<String> list = stream.collect(Collectors.toList());

Since Java 16 (recommended)
List<String> list = stream.toList();


Returns an unmodifiable list

Cleaner and preferred for most cases

With filtering and mapping
List<Integer> result = numbers.stream()
        .filter(n -> n > 10)
        .map(n -> n * 2)
        .toList();

If you need a mutable list
List<String> list = stream.collect(Collectors.toCollection(ArrayList::new));

From an array
List<String> list = Arrays.stream(array).toList();

From a collection
List<String> list = collection.stream().toList();

Summary
Approach	Mutable	Java Version
stream.toList()	‚ùå	16+
Collectors.toList()	‚ö†Ô∏è (implementation-dependent)	8+
Collectors.toCollection(ArrayList::new)	‚úÖ	8+

If you meant another language (e.g., Kotlin, Python, C# LINQ), tell me which one and I‚Äôll tailor the answer.

always get confused between Collector and Collectors. help me to understand the difference

This confusion is very common üôÇ ‚Äî the names are unfortunately similar. Let‚Äôs untangle them clearly and permanently.

1Ô∏è‚É£ Collector (singular) ‚Äî the idea / contract

Collector is an interface.

Think of it as:

‚ÄúA recipe that tells Java how to collect stream elements.‚Äù

It defines what is needed to perform a collection:

How to create the container

How to add elements

How to combine partial results (for parallel streams)

How to finish the result

public interface Collector<T, A, R> {
    Supplier<A> supplier();
    BiConsumer<A, T> accumulator();
    BinaryOperator<A> combiner();
    Function<A, R> finisher();
    Set<Characteristics> characteristics();
}


üëâ You never call these methods yourself.
The Stream API does that internally.

2Ô∏è‚É£ Collectors (plural) ‚Äî the factory / toolbox

Collectors is a utility class full of static factory methods that create Collector objects.

Think of it as:

‚ÄúA toolbox that gives you ready-made Collector recipes.‚Äù

Examples:

Collectors.toList()
Collectors.toSet()
Collectors.toMap(...)
Collectors.groupingBy(...)
Collectors.joining()


Each of these returns a Collector.

Collector<T, ?, List<T>> collector = Collectors.toList();

3Ô∏è‚É£ How they work together
collect() expects a Collector
<R, A> R collect(Collector<? super T, A, R> collector)


So you pass it one:

List<String> list = stream.collect(Collectors.toList());


What‚Äôs happening:

Collectors.toList() ‚Üí creates a Collector

collect(...) ‚Üí uses that Collector

4Ô∏è‚É£ Analogy (easy to remember)
üßë‚Äçüç≥ Cooking analogy
Java	Cooking
Collector	A recipe
Collectors	A recipe book
collect()	The cook

You:

stream.collect(Collectors.toList());


Means:

‚ÄúHey cook, use the recipe from the recipe book to prepare my dish.‚Äù

5Ô∏è‚É£ Custom Collector (rare, but clarifies things)

You can create your own Collector (usually only in advanced cases):

Collector<String, List<String>, List<String>> myCollector =
        Collector.of(
            ArrayList::new,
            List::add,
            (left, right) -> { left.addAll(right); return left; }
        );


And use it:

List<String> list = stream.collect(myCollector);


‚ö†Ô∏è Notice: you did not use Collectors here ‚Äî because you built the Collector yourself.

6Ô∏è‚É£ One-line memory trick

Collectors create Collectors
collect() consumes a Collector

7Ô∏è‚É£ When to use which?
You want to‚Ä¶	Use
Collect stream data	collect()
Get a ready-made collector	Collectors
Implement custom collection logic	Collector

If you want, I can also:

Compare collect() vs toList()

Explain groupingBy internally

Show why Collector has three generic types

Just tell me üëç

What is mutuable reduction in this statement ? I pick this from reader note from Java doc. A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel.

Great question ‚Äî this sentence from the Javadoc is dense, and ‚Äúmutable reduction‚Äù is the key term that causes confusion. Let‚Äôs unpack it slowly and precisely.

1Ô∏è‚É£ First: what is reduction?

A reduction is any operation that:

Takes many elements and produces one result

Examples:

int sum = stream.reduce(0, Integer::sum);     // many ‚Üí one
Optional<Integer> max = stream.max(Integer::compareTo);
List<String> list = stream.toList();           // many ‚Üí one (a List)


Even collecting into a list is a reduction ‚Äî the ‚Äúone result‚Äù just happens to be a collection.

2Ô∏è‚É£ What does mutable mean here?

Mutable means:

The result container is modified in place while processing elements

So instead of creating a new object for every step, Java:

Creates one container

Keeps adding to it

Example:

List<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);


The same ArrayList instance is mutated.

3Ô∏è‚É£ Mutable reduction ‚Äî definition in plain English

Mutable reduction =
‚ÄúA reduction where intermediate results are accumulated by mutating a container‚Äù

This is exactly what collect() does.

4Ô∏è‚É£ Example: Mutable vs Immutable reduction
‚ùå Immutable reduction (reduce)
List<Integer> result =
    stream.reduce(
        new ArrayList<>(),
        (list, e) -> {
            List<Integer> newList = new ArrayList<>(list);
            newList.add(e);
            return newList;
        }
    );


Creates a new list every time

Very inefficient

Functional, but slow

‚úÖ Mutable reduction (collect)
List<Integer> result =
    stream.collect(
        ArrayList::new,   // create container
        List::add,        // mutate container
        List::addAll      // combine containers
    );


One list per thread

Mutated in place

Efficient

This is why collect() exists.

5Ô∏è‚É£ Breaking down the Javadoc sentence

‚ÄúA mutable reduction operation‚Ä¶‚Äù
‚û°Ô∏è The result container is modified (not replaced)

‚Äú‚Ä¶that accumulates input elements into a mutable result container‚Äù
‚û°Ô∏è Elements are added to something like a List, Set, or Map

‚Äúoptionally transforming the accumulated result into a final representation‚Äù
‚û°Ô∏è Example: Collectors.collectingAndThen(...)

List<String> unmodifiable =
    stream.collect(
        Collectors.collectingAndThen(
            Collectors.toList(),
            Collections::unmodifiableList
        )
    );


‚ÄúReduction operations can be performed either sequentially or in parallel.‚Äù
‚û°Ô∏è In parallel streams:

Each thread gets its own mutable container

Containers are later combined

6Ô∏è‚É£ Why mutable reduction is safe in parallel streams

People often worry:

‚ÄúIsn‚Äôt mutation dangerous in parallel?‚Äù

Java avoids shared mutation by:

Giving each thread its own container

Combining them later using the combiner

List::addAll


So there is no shared mutable state.

7Ô∏è‚É£ Simple mental model
reduce()

Functional

Immutable

One value replaced repeatedly

collect()

Mutable

Container-based

Efficient

Designed for collections

8Ô∏è‚É£ One-sentence takeaway

Mutable reduction means ‚Äúcollecting stream elements by mutating a result container (like a List or Map) instead of creating a new result object for every element.‚Äù

If you want, I can next:

Contrast reduce() vs collect() line by line

Explain why reduce() should not be used to build collections

Visualize parallel collection with diagrams

Get smarter responses, upload files and images, and more.
Log in
Sign up for free

ChatGPT can make mistakes. Check important info. See Cookie Preferences.
We use cookies

We use cookies to help this site function, understand service usage, and support marketing efforts. Visit Manage Cookies to change preferences anytime. View our Cookie Policy for more info.